Линейный поиск
Алгоритм линейного поиска определяется на таких структурах данных как массивы, списки и надстройки над ними — очередь и стек. Такой алгоритм является «решением в лоб» и сводится к перебору одного элемента за другим и операции сравнения на каждом. Как правило, линейный поиск применяется к неотсортированным структурам.

Пусть на вход программы поступает массив из произвольного количества целых чисел и ещё одно целое число, которое будем проверять на вхождение в этот массив. Задача состоит в том, чтобы вернуть индекс первого вхождения элемента, если он входит в него, и False, если не входит.

def find(array, element):
    for i, a in enumerate(array):
        if a == element:
            return i
    return False

array = list(map(int, input().split()))
element = int(input())

print(find(array, element))
В худшем случае этот алгоритм работает за , потому что, если элемент не входит в массив, придётся провести  сравнений. Все они не увенчаются успехом.

Линейный алгоритм поиска может применяться для следующих целей:

Нахождение минимального/максимального элемента.
Поиск элемента с определённым значением.
Количество вхождений элемента в массив.
Количество элементов больше заданного.
В случае нахождения минимального (максимального) элемента линейный поиск имеет смысл применять только при небольшом количестве элементов, и если структура не отсортирована. Для больших структур, а тем более, если они уже сортированы, имеет смысл применять более эффективные алгоритмы.





Двоичный поиск
Алгоритм двоичного поиска является более совершенным, чем линейный поиск, однако он накладывает на структуру сильное ограничение — она должна быть отсортирована.

Допустим, что у нас стоит такая же задача — найти индекс определённого элемента в массиве. В связи с тем, что алгоритм может искать только в отсортированном массиве, используем генератор последовательных чисел range. Суть двоичного поиска сводится к тому, что на каждой итерации размер исследуемого массива уменьшается в 2 раза.

def binary_search(array, element, left, right): 
    if left > right:  # если левая граница превысила правую,
        return False  # значит, элемент отсутствует
    
    middle = (right+left) // 2  # находим середину
    if array[middle] == element:  # если элемент в середине
        return middle  # возвращаем этот индекс
    elif element < array[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(array, element, left, middle-1)
    else:  # иначе в правой
        return binary_search(array, element, middle+1, right)

element = int(input())
array = [i for i in range(1,100)] # 1,2,3,4,...

# запускаем алгоритм на левой и правой границе
print(binary_search(array, element, 0, 99))
Математически доказывается, что сложность такого алгоритма , а как вы должны помнить из начала этого модуля — логарифмическая сложность намного лучше, чем линейная. Ура! Мы получили очень эффективный алгоритм поиска. Только вот сортировать нужно… Но и с этим мы познакомимся чуть позже.

Несколько более сложный алгоритм, но в чём-то схожий с двоичным поиском — это использование двоичных деревьев поиска. Этот алгоритм концентрирует свойства бинарных деревьев для оптимизации задачи поиска. С ним можно ознакомиться в дополнительных материалах к теме.